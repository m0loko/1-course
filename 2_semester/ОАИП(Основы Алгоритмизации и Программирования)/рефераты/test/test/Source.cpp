#include<iostream>
using namespace std;

struct node
{
    int  elem;       // хранит значение элемента
    node* sled;      // указатель на следующее звено в списке
};

class Spisok {
private:
    node* phead, * Res; // phead - указатель на начало списка (заглавное звено), Res - указатель на найденное звено
public:
    Spisok() { phead = new(node); Res = NULL; } // конструктор: выделение памяти для заглавного звена
    ~Spisok() { delete phead; } // деструктор: освобождение памяти для заглавного звена
    void POSTROENIE(); // метод для построения списка
    void VYVOD();     // метод для вывода списка
    node* POISK(int);  // метод для поиска элемента в списке
    void YDALE();     // метод для удаления элемента после найденного
    void YDALE1();    // метод для удаления найденного элемента
    void OCHISTKA();  // метод для очистки списка из памяти
};

void main()
{
    setlocale(LC_ALL, "Rus"); // установка русской локализации
    Spisok A;  // создание объекта A типа Spisok
    int   el;  // переменная для хранения вводимого элемента
    node* Res_Zn;  // переменная для хранения результата поиска

    A.POSTROENIE();  // построение списка
    A.VYVOD();       // вывод списка
    cout << "\nВведите элемент звена, после которого ";
    cout << "осуществляется удаление:\n";
    cin >> el; // ввод элемента для удаления
    Res_Zn = A.POISK(el); // поиск звена с данным элементом
    if (Res_Zn != NULL && (*Res_Zn).sled != NULL) // если звено найдено и не последнее
    {
        A.YDALE();  // удаление звена после найденного
        A.VYVOD();  // вывод списка после удаления
    }
    else  cout << "Звена с заданным элементом в списке нет!"; // если звено не найдено

    cout << "\nВведите удаляемый элемент звена:\n";
    cin >> el; // ввод элемента для удаления
    Res_Zn = A.POISK(el); // поиск элемента
    if (A.POISK(el) != NULL) // если элемент найден
    {
        A.YDALE1(); // удаление найденного элемента
        A.VYVOD();  // вывод списка после удаления
        cout << endl;
    }
    else  cout << "Звена с заданным элементом в списке нет!"; // если элемент не найден

    A.OCHISTKA(); // очистка списка из памяти

    cout << "\n";
    system("PAUSE"); // пауза до нажатия клавиши
}

void Spisok::POSTROENIE()
// построение однонаправленного списка с заглавным звеном.
// phead - указатель на заглавное звено
{
    node* t;  // указатель для обхода списка
    int  el;   // вводимый элемент

    t = phead; (*t).sled = NULL; // инициализация заглавного звена
    cout << "Вводите элементы звеньев списка: ";
    cin >> el; // ввод первого элемента
    while (el != 0)  // пока не введено 0
    {
        (*t).sled = new (node);  // выделение памяти для нового элемента
        t = (*t).sled;           // переход к новому элементу
        (*t).elem = el;          // присваиваем значение элементу
        (*t).sled = NULL;        // устанавливаем указатель на NULL
        cin >> el;  // ввод следующего элемента
    }
}

void Spisok::VYVOD()
// вывод содержимого однонаправленного списка.
// phead - указатель на заглавное звено.
{
    node* t;  // указатель для обхода списка

    t = phead; t = (*t).sled;  // начинаем с первого элемента
    cout << "Список: ";
    while (t != NULL)  // пока не дошли до конца списка
    {
        cout << (*t).elem << " "; // выводим значение элемента
        t = (*t).sled;  // переходим к следующему элементу
    }
}

node* Spisok::POISK(int el)
// поиск звена с элементом el в списке, заданном указателем phead.
// в случае успешного поиска в Res находится адрес искомого звена
// списка. В противном случае Res содержит NULL.
{
    node* t;  // указатель для обхода списка

    Res = NULL;  // инициализация результата поиска
    t = phead;  // начинаем с заглавного звена
    t = (*t).sled;  // переходим к первому элементу
    while (t != NULL && Res == NULL)  // пока не дошли до конца и не нашли элемент
        if ((*t).elem == el)  // если элемент найден
            Res = t;  // присваиваем результат поиска
        else
            t = (*t).sled;  // переходим к следующему элементу
    return Res;  // возвращаем результат
}

void Spisok::YDALE()
// удаление звена, расположенного после звена,
// на которое указывает ссылка Res.
{
    node* q;  // временный указатель для удаления

    q = (*Res).sled;  // получаем указатель на следующий элемент
    if (q != NULL)  // если следующий элемент существует
    {
        (*Res).sled = (*(*Res).sled).sled;  // перенаправляем указатель на следующий элемент
        delete q;  // освобождаем память для удаляемого элемента
    }
    else
        cout << "Звено с заданным элементом - последнее!\n"; // если элемент последний
}

void Spisok::YDALE1()
// удаление звена, на которое указывает ссылка Res.
{
    node* q, * q1, * q2;  // временные указатели

    q = (*Res).sled;  // получаем указатель на следующий элемент
    if (q != NULL)  // если следующий элемент существует
    {
        (*Res).elem = (*q).elem;  // копируем значение из следующего элемента
        (*Res).sled = (*q).sled;  // перенаправляем указатель на следующий элемент
        delete q;  // освобождаем память для удаляемого элемента
    }
    else  // если элемент последний
    {
        q1 = phead;  // начинаем с заглавного звена
        q2 = (*q1).sled;  // переходим к первому элементу
        while (q2 != Res)  // ищем элемент, перед которым нужно удалить
        {
            q1 = q2;  // переходим к следующему элементу
            q2 = (*q2).sled;
        }
        (*q1).sled = NULL;  // перенаправляем указатель на NULL
        q2 = NULL;  // освобождаем указатель
        delete Res;  // удаляем текущий элемент
    }
}

void Spisok::OCHISTKA()
// удаление однонаправленного списка из памяти.
// phead - указатель на заглавное звено списка.
{
    node* q, * q1;  // рабочие указатели

    q = phead;  // начинаем с заглавного звена
    q1 = (*q).sled;  // указатель q1 "опережает" указатель q
    while (q1 != NULL)  // пока не дошли до конца списка
    {
        q = q1;  // переходим к следующему элементу
        q1 = (*q1).sled;  // переходим к следующему элементу
        delete q;  // освобождаем память для текущего элемента
    }
}
